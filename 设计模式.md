# 设计模式原则
* 开闭原则-Open Closed Principle
    对拓展开放，对修改关闭。 模块尽量不修改旧的实现，通过接口或者抽象类来约束拓展。
* 单一职责-Single Responsibility Principle
    一个类不要兼职太多功能，时刻判断下是否由这个类处理改原则。也就是说一个类最好最有一个原因引起它变化，错误例子如持久化逻辑和业务逻辑放一起
*  里氏代换-Liskov Substitution Principle
    对开闭原则的拓展，就是 能用基类的地方 必须能 用子类来替换。它是实现开闭原则的基础之一
* 依赖倒转-Dependency Inversion Principle
    程序依赖于 抽象，不要依赖于具体实现。说人话就是 面向接口编程， 在参数，返回，调用等等地方都使用抽象的类。
* 接口隔离-Interface Segregation Principle
    接口尽量细化，一个接口不要包括太多方法
以上就是常说的SOLID(英文首字母大写)

* 合成复用原则-Composite Reuse Principle
    尽量使用合成、聚合，少使用继承来达到复用的目的。有明确逻辑继承关系和接口继承的再用. 继承的话基类发生变化，所有子类也需要发生变化，如果合成或聚合的话，可以动态指定。
* 迪米特法则-Law of Demeter
    也称最少知识原则，核心就是减少类之间的耦合，只和本身、持有的成员对象、入参对象、它创建的对象等通信。
    
各种设计模式都是在上面原则基础上创建的，只是手段，核心原则才是重要的。

# 常见设计模式
* 装饰者模式
   对原始类进行功能拓展，增强自身的接口.而类似的代理模式是 拓展了其他无关的功能，其他一个代理接口.
    装饰者类和原始类继承通用的父类，这样可以在原始类的基础上不断进行装饰，拓展已有的功能.
    [装饰者模式解析](https://juejin.cn/post/6999268990971281439)
    [从javaIO库来分析装饰者模式](https://freegeektime.com/100039001/204845/)
* 代理模式
    和装饰者模式，代理模式是通过引入代理的方式，对原始类来附加功能. 比如对某个功能，增加性能监控接口，可以通过代理模式实现。让代理类和原始类继承公共的接口.
    代理模式和装饰模式：第一是增强自身和拓展功能  第二-代理模式是自己管理原始类，装饰模式由客户端自由选择进行装饰.
    代理模式常用在业务系统中开发一些非功能性需求(比如：监控、统计、鉴权、限流、事务、幂等、日志),用于和原始业务进行解耦.
    [代理模式-极客时间](https://freegeektime.com/100039001/201823/)
    [代理模式-dunwu](https://dunwu.github.io/design/pages/5a865c/#%E4%BC%98%E5%8C%96%E7%89%88%E6%9C%AC)

